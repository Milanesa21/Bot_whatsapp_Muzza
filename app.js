// librerias para el bot
const {
  createBot,
  createProvider,
  createFlow,
  addKeyword,
  EVENTS,
} = require("@bot-whatsapp/bot");
require("dotenv").config();
const QRPortalWeb = require("@bot-whatsapp/portal");
const BaileysProvider = require("@bot-whatsapp/provider/baileys");
const MockAdapter = require("@bot-whatsapp/database/json");
const path = require("path");
const fs = require("fs");
const chat = require("./chatgpt");
const { handlerAI } = require("./whisper");

// Creaci√≥n de carpeta temporal para archivos de voz si no existe
if (!fs.existsSync("./tmp")) {
  fs.mkdirSync("./tmp");
}

// Datos del pedido
let pedidoActual = {
  tipo: null, // "pizzeria" o "panaderia"
  items: [],
  delivery: null,
  detalles: null,
  nombreCliente: null,
  metodoPago: null,
  horario: null,
  total: 0,
};

// Reset pedido
const resetPedido = () => {
  pedidoActual = {
    tipo: null,
    items: [],
    delivery: null,
    detalles: null,
    nombreCliente: null,
    metodoPago: null,
    horario: null,
    total: 0,
  };
};

// Archivos para mensajes
const menuPizzeriaPath = path.join(__dirname, "mensajes", "menuPizzeria.txt");
const menuPizzeria = fs.readFileSync(menuPizzeriaPath, "utf-8");

const menuPanaderiaPath = path.join(__dirname, "mensajes", "menuPanaderia.txt");
const menuPanaderia = fs.readFileSync(menuPanaderiaPath, "utf-8");

const pathConsultas = path.join(__dirname, "mensajes", "promptConsultas.txt");
const promptConsultas = fs.readFileSync(pathConsultas, "utf-8");

// Flow para convertir notas de voz en texto y procesarlas
const flowVoice = addKeyword(EVENTS.VOICE_NOTE).addAction(
  async (ctx, ctxFn) => {
    try {
      // Convertir nota de voz a texto
      const texto = await handlerAI(ctx);
      console.log("Texto convertido de voz:", texto);

      // Analizar el mensaje para determinar la intenci√≥n
      let intencion = await detectarIntencion(texto);

      // Dirigir al usuario seg√∫n su intenci√≥n
      await procesarIntencion(intencion, texto, ctxFn);
    } catch (error) {
      console.error("Error en procesamiento de voz:", error);
      await ctxFn.flowDynamic(
        "Lo siento, no pude procesar tu mensaje de voz. ¬øPodr√≠as intentar de nuevo o enviarlo por texto?"
      );
    }
  }
);

// Funci√≥n para detectar la intenci√≥n del usuario desde texto
const detectarIntencion = async (texto) => {
  const textoLower = texto.toLowerCase();

  // Palabras clave para cada categor√≠a
  const palabrasPizzeria = [
    "pizza",
    "pizzas",
    "pizzer√≠a",
    "pizzeria",
    "muzzarella",
    "calabresa",
  ];
  const palabrasPanaderia = [
    "pan",
    "panader√≠a",
    "panaderia",
    "facturas",
    "medialunas",
    "torta",
  ];
  const palabrasConsulta = [
    "consulta",
    "pregunta",
    "informaci√≥n",
    "informacion",
    "duda",
    "ayuda",
  ];

  // Verificar coincidencias
  if (palabrasPizzeria.some((palabra) => textoLower.includes(palabra))) {
    return "pizzeria";
  } else if (
    palabrasPanaderia.some((palabra) => textoLower.includes(palabra))
  ) {
    return "panaderia";
  } else if (palabrasConsulta.some((palabra) => textoLower.includes(palabra))) {
    return "consulta";
  }

  // Si no hay coincidencia clara, usar IA para interpretar
  const prompt =
    "Determina si este mensaje se refiere a una pizzer√≠a, panader√≠a o es una consulta general. Responde solo con una palabra: 'pizzeria', 'panaderia' o 'consulta'.";
  const respuesta = await chat(prompt, texto);
  return respuesta.toLowerCase();
};

// Procesar la intenci√≥n detectada
const procesarIntencion = async (intencion, texto, ctxFn) => {
  switch (intencion) {
    case "pizzeria":
      pedidoActual.tipo = "pizzeria";
      await ctxFn.flowDynamic("Has seleccionado la opci√≥n de Pizzer√≠a üçï");
      return ctxFn.gotoFlow(flowMenuPizzeria);
    case "panaderia":
      pedidoActual.tipo = "panaderia";
      await ctxFn.flowDynamic("Has seleccionado la opci√≥n de Panader√≠a ü•ê");
      return ctxFn.gotoFlow(flowMenuPanaderia);
    case "consulta":
      await ctxFn.flowDynamic("Vamos a resolver tu consulta üìù");
      return ctxFn.gotoFlow(flowConsultas);
    default:
      await ctxFn.flowDynamic(
        "No he podido entender tu solicitud. ¬øPodr√≠as elegir una opci√≥n: pizzer√≠a üçï, panader√≠a ü•ê o consulta üìù?"
      );
  }
};

// Flow principal de bienvenida
const flowPrincipal = addKeyword([
  "Hola",
  "alo",
  "ole",
  "Buenos d√≠as",
  "Buenas tardes",
  "Buenas noches",
  "Saludos",
  "Hola, buenas",
  "Hola, buenos d√≠as",
  "Hola, buenas tardes",
  "Hola, buenas noches",
  "Hola, ¬øc√≥mo est√°n?",
  "Buen d√≠a",
  "Hola, buen d√≠a",
  "Hola, buenas noches",
  "Hola, buenas tardes",
  "Hola, ¬øc√≥mo est√°s?",
  "Hola, ¬øc√≥mo est√°?",
  "ola",
  "holi",
  "holis",
  "holas",
  "holas",
  "holus",
  "oa",
])
  .addAction(async (_, { flowDynamic }) => {
    // Reset el pedido al inicio
    resetPedido();
    await flowDynamic(
      "üôå ¬°Hola! Bienvenido a Muzza, tu lugar de pizzer√≠a y panader√≠a üçïü•ê"
    );
  })
  .addAnswer("¬øQu√© deseas hacer hoy?")
  .addAnswer(
    [
      "1Ô∏è‚É£ Ver nuestro men√∫ de *Pizzer√≠a* üçï",
      "2Ô∏è‚É£ Ver nuestro men√∫ de *Panader√≠a* ü•ê",
      "3Ô∏è‚É£ Realizar una *Consulta* üìù",
      "\nPuedes responder con el n√∫mero o escribir lo que deseas.",
    ].join("\n"),
    { capture: true },
    async (ctx, { gotoFlow, flowDynamic, fallBack }) => {
      const respuesta = ctx.body.toLowerCase();

      if (respuesta.includes("1") || respuesta.includes("pizz")) {
        pedidoActual.tipo = "pizzeria";
        await flowDynamic("Has seleccionado la opci√≥n de Pizzer√≠a üçï");
        return gotoFlow(flowMenuPizzeria);
      } else if (respuesta.includes("2") || respuesta.includes("pan")) {
        pedidoActual.tipo = "panaderia";
        await flowDynamic("Has seleccionado la opci√≥n de Panader√≠a ü•ê");
        return gotoFlow(flowMenuPanaderia);
      } else if (respuesta.includes("3") || respuesta.includes("consul")) {
        await flowDynamic("Vamos a resolver tu consulta üìù");
        return gotoFlow(flowConsultas);
      } else {
        return fallBack(
          "Por favor, selecciona una opci√≥n v√°lida: 1 (Pizzer√≠a), 2 (Panader√≠a) o 3 (Consulta)"
        );
      }
    }
  );

// Flow para el men√∫ de Pizzer√≠a
const flowMenuPizzeria = addKeyword(EVENTS.ACTION)
  .addAnswer("üçï *MEN√ö DE PIZZER√çA* üçï")
  .addAnswer(
    menuPizzeria,
    { capture: true },
    async (ctx, { flowDynamic, fallBack }) => {
      const seleccion = ctx.body;
      if (
        !isNaN(seleccion) &&
        parseInt(seleccion) >= 1 &&
        parseInt(seleccion) <= 5
      ) {
        const opcion = parseInt(seleccion);
        let item = {
          nombre: "",
          precio: 0,
        };

        switch (opcion) {
          case 1:
            item.nombre = "Pizza Muzzarella";
            item.precio = 2500;
            break;
          case 2:
            item.nombre = "Pizza Calabresa";
            item.precio = 3000;
            break;
          case 3:
            item.nombre = "Pizza Especial";
            item.precio = 3200;
            break;
          case 4:
            item.nombre = "Pizza Napolitana";
            item.precio = 2800;
            break;
          case 5:
            item.nombre = "Pizza Fugazzeta";
            item.precio = 2900;
            break;
        }

        pedidoActual.items.push(item);
        pedidoActual.total += item.precio;

        await flowDynamic(
          `Has agregado ${item.nombre} ($${item.precio}) a tu pedido. Total actual: $${pedidoActual.total}`
        );
        return gotoFlow(flowAgregarMas);
      } else {
        return fallBack("Por favor, selecciona una opci√≥n v√°lida (1-5)");
      }
    }
  );

// Flow para el men√∫ de Panader√≠a
const flowMenuPanaderia = addKeyword(EVENTS.ACTION)
  .addAnswer("ü•ê *MEN√ö DE PANADER√çA* ü•ê")
  .addAnswer(
    menuPanaderia,
    { capture: true },
    async (ctx, { flowDynamic, fallBack }) => {
      const seleccion = ctx.body;
      if (
        !isNaN(seleccion) &&
        parseInt(seleccion) >= 1 &&
        parseInt(seleccion) <= 5
      ) {
        const opcion = parseInt(seleccion);
        let item = {
          nombre: "",
          precio: 0,
        };

        switch (opcion) {
          case 1:
            item.nombre = "Pan Franc√©s (kg)";
            item.precio = 800;
            break;
          case 2:
            item.nombre = "Medialunas (docena)";
            item.precio = 1200;
            break;
          case 3:
            item.nombre = "Facturas (docena)";
            item.precio = 1400;
            break;
          case 4:
            item.nombre = "Torta (porci√≥n)";
            item.precio = 600;
            break;
          case 5:
            item.nombre = "Sandwich de miga (unidad)";
            item.precio = 400;
            break;
        }

        pedidoActual.items.push(item);
        pedidoActual.total += item.precio;

        await flowDynamic(
          `Has agregado ${item.nombre} ($${item.precio}) a tu pedido. Total actual: $${pedidoActual.total}`
        );
        return gotoFlow(flowAgregarMas);
      } else {
        return fallBack("Por favor, selecciona una opci√≥n v√°lida (1-5)");
      }
    }
  );

// Flow para preguntar si desea agregar m√°s items
const flowAgregarMas = addKeyword(EVENTS.ACTION)
  .addAnswer("¬øDeseas agregar algo m√°s a tu pedido?")
  .addAnswer(
    ["1Ô∏è‚É£ S√≠, agregar m√°s productos", "2Ô∏è‚É£ No, continuar con el pedido"].join(
      "\n"
    ),
    { capture: true },
    async (ctx, { gotoFlow, fallBack }) => {
      const respuesta = ctx.body.toLowerCase();

      if (
        respuesta.includes("1") ||
        respuesta.includes("si") ||
        respuesta.includes("s√≠")
      ) {
        // Verificar si el √∫ltimo pedido fue de pizzer√≠a o panader√≠a
        if (pedidoActual.tipo === "pizzeria") {
          return gotoFlow(flowMenuPizzeria);
        } else {
          return gotoFlow(flowMenuPanaderia);
        }
      } else if (respuesta.includes("2") || respuesta.includes("no")) {
        return gotoFlow(flowDelivery);
      } else {
        return fallBack(
          "Por favor, indica si deseas agregar m√°s productos (1) o continuar con el pedido (2)"
        );
      }
    }
  );

// Flow para preguntar sobre delivery
const flowDelivery = addKeyword(EVENTS.ACTION)
  .addAnswer("¬øC√≥mo deseas recibir tu pedido?")
  .addAnswer(
    [
      "1Ô∏è‚É£ Delivery a domicilio (+$500)",
      "2Ô∏è‚É£ Paso a retirarlo personalmente",
    ].join("\n"),
    { capture: true },
    async (ctx, { gotoFlow, flowDynamic, fallBack }) => {
      const respuesta = ctx.body.toLowerCase();

      if (
        respuesta.includes("1") ||
        respuesta.includes("delivery") ||
        respuesta.includes("domicilio")
      ) {
        pedidoActual.delivery = true;
        pedidoActual.total += 500; // Cargo extra por delivery
        await flowDynamic(
          "Has seleccionado delivery a domicilio. Se ha agregado un cargo de $500. Total actualizado: $" +
            pedidoActual.total
        );
        return gotoFlow(flowDetallesPedido);
      } else if (
        respuesta.includes("2") ||
        respuesta.includes("retir") ||
        respuesta.includes("paso")
      ) {
        pedidoActual.delivery = false;
        await flowDynamic(
          "Has seleccionado retirar personalmente. Total del pedido: $" +
            pedidoActual.total
        );
        return gotoFlow(flowDetallesPedido);
      } else {
        return fallBack(
          "Por favor, indica si deseas delivery (1) o retirarlo personalmente (2)"
        );
      }
    }
  );

// Flow para detalles del pedido
const flowDetallesPedido = addKeyword(EVENTS.ACTION).addAnswer(
  "¬øDeseas agregar alg√∫n detalle espec√≠fico en tu pedido? (por ejemplo, sin cebolla, bien cocido, etc.)",
  { capture: true },
  async (ctx, { gotoFlow }) => {
    pedidoActual.detalles = ctx.body;
    return gotoFlow(flowNombreCliente);
  }
);

// Flow para nombre del cliente
const flowNombreCliente = addKeyword(EVENTS.ACTION).addAnswer(
  "Por favor, indica a nombre de qui√©n estar√° el pedido",
  { capture: true },
  async (ctx, { gotoFlow }) => {
    pedidoActual.nombreCliente = ctx.body;
    return gotoFlow(flowMetodoPago);
  }
);

// Flow para m√©todo de pago
const flowMetodoPago = addKeyword(EVENTS.ACTION)
  .addAnswer("¬øC√≥mo deseas pagar?")
  .addAnswer(
    ["1Ô∏è‚É£ Efectivo", "2Ô∏è‚É£ Transferencia"].join("\n"),
    { capture: true },
    async (ctx, { gotoFlow, fallBack }) => {
      const respuesta = ctx.body.toLowerCase();

      if (respuesta.includes("1") || respuesta.includes("efectivo")) {
        pedidoActual.metodoPago = "Efectivo";
        return gotoFlow(flowHorario);
      } else if (respuesta.includes("2") || respuesta.includes("transf")) {
        pedidoActual.metodoPago = "Transferencia";
        return gotoFlow(flowHorario);
      } else {
        return fallBack(
          "Por favor, indica si pagar√°s con efectivo (1) o transferencia (2)"
        );
      }
    }
  );

// Flow para horario de entrega
const flowHorario = addKeyword(EVENTS.ACTION)
  .addAnswer("¬øPara qu√© horario deseas tu pedido?")
  .addAnswer(
    ["1Ô∏è‚É£ Lo antes posible", "2Ô∏è‚É£ Para un horario espec√≠fico"].join("\n"),
    { capture: true },
    async (ctx, { gotoFlow, flowDynamic, fallBack }) => {
      const respuesta = ctx.body.toLowerCase();

      if (
        respuesta.includes("1") ||
        respuesta.includes("antes") ||
        respuesta.includes("posible")
      ) {
        pedidoActual.horario = "Lo antes posible";
        return gotoFlow(flowConfirmacionPedido);
      } else if (
        respuesta.includes("2") ||
        respuesta.includes("especifico") ||
        respuesta.includes("espec√≠fico")
      ) {
        await flowDynamic(
          "¬øPara qu√© horario espec√≠fico lo deseas? (Ej: 20:30)"
        );
        return fallBack();
      } else if (respuesta.includes(":") || /\d+[:]\d+/.test(respuesta)) {
        // Si el usuario ingres√≥ directamente un horario en formato HH:MM
        pedidoActual.horario = respuesta;
        return gotoFlow(flowConfirmacionPedido);
      } else {
        return fallBack(
          "Por favor, indica si lo deseas lo antes posible (1) o especifica un horario"
        );
      }
    }
  );

// Flow de confirmaci√≥n final del pedido
const flowConfirmacionPedido = addKeyword(EVENTS.ACTION)
  .addAction(async (_, { flowDynamic }) => {
    // Crear resumen del pedido
    let resumen = [
      "üßæ *RESUMEN DE TU PEDIDO* üßæ",
      `üë§ A nombre de: *${pedidoActual.nombreCliente}*`,
      "",
      "üìã *Productos:*",
    ];

    pedidoActual.items.forEach((item, index) => {
      resumen.push(`${index + 1}. ${item.nombre} - $${item.precio}`);
    });

    resumen = resumen.concat([
      "",
      `üöö *Entrega:* ${
        pedidoActual.delivery ? "Delivery (+$500)" : "Retiro en local"
      }`,
      `üí∞ *M√©todo de pago:* ${pedidoActual.metodoPago}`,
      `‚è∞ *Horario:* ${pedidoActual.horario}`,
      `üí≤ *Total a pagar:* $${pedidoActual.total}`,
      "",
    ]);

    if (pedidoActual.detalles && pedidoActual.detalles.trim() !== "") {
      resumen.push(`üìù *Detalles:* ${pedidoActual.detalles}`);
    }

    await flowDynamic(resumen.join("\n"));
  })
  .addAnswer("¬øConfirmas este pedido?")
  .addAnswer(
    ["1Ô∏è‚É£ S√≠, confirmar pedido", "2Ô∏è‚É£ No, cancelar pedido"].join("\n"),
    { capture: true },
    async (ctx, { gotoFlow, flowDynamic, fallBack }) => {
      const respuesta = ctx.body.toLowerCase();

      if (
        respuesta.includes("1") ||
        respuesta.includes("si") ||
        respuesta.includes("s√≠") ||
        respuesta.includes("conf")
      ) {
        await flowDynamic(
          [
            "‚úÖ *¬°Pedido confirmado!* ‚úÖ",
            "",
            "Tu pedido ha sido registrado con √©xito.",
            pedidoActual.delivery
              ? "Te enviaremos tu pedido a la direcci√≥n proporcionada."
              : "Puedes pasar a retirarlo por nuestro local.",
            "",
            "¬°Gracias por tu compra! üòä",
          ].join("\n")
        );
        resetPedido();
        return gotoFlow(flowPrincipal);
      } else if (
        respuesta.includes("2") ||
        respuesta.includes("no") ||
        respuesta.includes("cancel")
      ) {
        await flowDynamic(
          [
            "‚ùå *Pedido cancelado* ‚ùå",
            "",
            "Has cancelado tu pedido. Puedes iniciar uno nuevo cuando lo desees.",
            "",
            "¬°Gracias por contactarnos! üòä",
          ].join("\n")
        );
        resetPedido();
        return gotoFlow(flowPrincipal);
      } else {
        return fallBack(
          "Por favor, indica si confirmas (1) o cancelas (2) el pedido"
        );
      }
    }
  );

// Flow de consultas
const flowConsultas = addKeyword(EVENTS.ACTION)
  .addAnswer("üìù *Consultas* üìù")
  .addAnswer(
    "¬øEn qu√© podemos ayudarte?",
    { capture: true },
    async (ctx, ctxFn) => {
      const prompt = promptConsultas;
      const consulta = ctx.body;
      const answer = await chat(prompt, consulta);
      await ctxFn.flowDynamic(answer);

      // Preguntar si desea hacer un pedido despu√©s de la consulta
      await ctxFn.flowDynamic(
        [
          "¬øDeseas realizar un pedido ahora?",
          "",
          "1Ô∏è‚É£ S√≠, quiero hacer un pedido",
          "2Ô∏è‚É£ No, gracias",
        ].join("\n")
      );

      return ctxFn.fallBack();
    }
  )
  .addAction({ capture: true }, async (ctx, { gotoFlow, fallBack }) => {
    const respuesta = ctx.body.toLowerCase();

    if (
      respuesta.includes("1") ||
      respuesta.includes("si") ||
      respuesta.includes("s√≠")
    ) {
      return gotoFlow(flowPrincipal);
    } else if (respuesta.includes("2") || respuesta.includes("no")) {
      return fallBack("Entendido. Si necesitas algo m√°s, estamos para ayudarte. ¬°Gracias por contactarnos!");
    } else {
      return fallBack(
        "Por favor, indica si deseas hacer un pedido (1) o no (2)"
      );
    }
  });

// En caso que no se reconozca la palabra
const flowWelcome = addKeyword(EVENTS.WELCOME).addAnswer(
  "Lo siento, pero no reconozco esa palabra. ¬øNecesitas ayuda con pizzer√≠a üçï, panader√≠a ü•ê, o tienes alguna consulta üìù?"
);

// Inicializaci√≥n del bot
const main = async () => {
  try {
    const adapterDB = new MockAdapter();
    const adapterFlow = createFlow([
      flowPrincipal,
      flowWelcome,
      flowMenuPizzeria,
      flowMenuPanaderia,
      flowAgregarMas,
      flowDelivery,
      flowDetallesPedido,
      flowNombreCliente,
      flowMetodoPago,
      flowHorario,
      flowConfirmacionPedido,
      flowConsultas,
      flowVoice,
    ]);
    const adapterProvider = createProvider(BaileysProvider);

    createBot({
      flow: adapterFlow,
      provider: adapterProvider,
      database: adapterDB,
    });

    QRPortalWeb();
  } catch (error) {
    console.error("Error en main:", error);
  }
};

main();